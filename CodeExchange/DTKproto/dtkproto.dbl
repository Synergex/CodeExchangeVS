;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;; Title:       dtkproto.dbl
;;
;; Type:        Application
;;
;; Description: Generates source that explicitly calls UI Toolkit callback
;;              methods
;;
;; Author:      William Hawkins, Synergex Professional Services Group
;;
;; Copyright:   ©Synergex International Inc.  All rights reserved.
;;
;; WARNING:     If you were given this code by a Synergex employee then
;;              you may use and modify it freely for use within your
;;              applications.
;;
;;              However, you may not under any circumstances distribute
;;              this code, or any modified version of this code, to any
;;              third party without first obtaining written permission to
;;              do so from Synergex.  In using this code you accept that it
;;              is provided as is, and without support or warranty.
;;
;;              Neither Synergex or the author accept any responsibility
;;              for any losses or damages of any nature which may arise
;;              from the use of this code.  This header information must
;;              remain unaltered in the code at all times.  Possession of
;;              this code, or any modified version of this code, indicates
;;              your acceptance of these terms.
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;;
;; This program will create a source file (per window library) that contains
;; explicit xcalls to all the UI Toolkit callback methods used.  The source
;; file produced can be compiled, for comparison with prototype files
;; generated by DBLPROTO.
;;
;; You may need to add IMPORTs or .INCLUDEs to the source generated,
;; to resolve namespace issues.
;;
;; If you have made any of the UI Toolkit methoddata parameters REQUIRED,
;; compiling the generated source will generate an error. Any REQPARM errors,
;; on or after the first methoddata parameter number can be ignored.  The
;; parameter number of the first methoddata parameter is appended to the
;; source line as a comment, to help identify this issue.
;;
;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

main
external function
    mainprog    ,i
endexternal
record
    stopStatus  ,i4
endrecord
proc
    try
        stopStatus = %mainprog()
    catch (excp ,@Exception)
    begin
        data ttCh ,i4, %syn_freechn()
        open(ttCh, O, 'TT:')
        writes(ttCh, excp.Message)
        writes(ttCh, excp.StackTrace)
        close ttCh
.ifdef DBLNET
        StopMessage()
.endc ;DBLNET
        stopStatus = D_EXIT_FAILURE
    end
    endtry

    xcall flags(7000000, 1)
    stop stopStatus
endmain

;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

function mainprog ,i

.define DTKPROTO_VERSION    "v1.0.0"

.include 'WND:tools.def'

external function
        process_window_library  ,i
endexternal

.define D_MAX_ARGS  10
.define D_DTK_FIRST_CHANNEL 10

.align
record lcl_vars
        args        ,[D_MAX_ARGS]a256   ;-w window name from command line
        argCount    ,i4                 ;number of window names provided
        wndStatus   ,[D_MAX_ARGS]i4     ;window process status
        ctr         ,i4                 ;loop counter
        stopStatus  ,i4                 ;program exit status
        logging     ,boolean            ;no User Interface interaction
        version     ,a12                ;current UI Toolkit version
endrecord

proc

        init lcl_vars
        stopStatus = D_EXIT_SUCCESS

        xcall dtk_start()

        xcall u_version(version)
        xcall u_checkversion("UI Toolkit", version, '9.2.1a')

        if(%u_cmdlinopt('h') || %u_cmdlinopt('?'))
            begin
            writes(g_terminal, "dbr dtkproto -w windowLibary [windowLibary2 ... windowLibary"+%string(D_MAX_ARGS)+"] [-l]")
            writes(g_terminal, "")
            writes(g_terminal, "-l = log errors to file")
            goto exitProgram
            end

        if(%u_cmdlinopt('l '))
            logging = TRUE

        if(!%u_cmdlinopt('w ', D_MAX_ARGS, args, argCount))
            begin
            xcall getlog('DTKPROTO_WINLIB', args[1], ctr)
            if(ctr > 0) then
                argCount = 1
            else
                argCount = 0
            end

        if(argCount > 0) then
            begin
            for ctr from 1 thru argCount
                wndStatus[ctr] = %process_window_library(args[ctr], logging)

            if(g_terminal > 0) then
                begin
                writes(g_terminal, "")
                writes(g_terminal, "")
                for ctr from 1 thru argCount
                    begin
                    using wndStatus[ctr] select
                    (0),
                        writes(g_terminal, args[ctr](1:%trim(args[ctr])) + " PROCESSED")
                    (),
                        begin
                        writes(g_terminal, args[ctr](1:%trim(args[ctr])) + " FAILED   status="+%string(wndStatus[ctr]))
                        stopStatus = D_EXIT_FAILURE
                        end
                    endusing
                    end
                end
            else
                begin
                if(wndStatus[ctr])
                    stopStatus = D_EXIT_FAILURE
                end
            end
        else
            begin
            if(g_terminal > 0)
                writes(g_terminal, "No window library name provided")
            stopStatus = D_EXIT_FAILURE
            end

        if(g_terminal > 0)
            begin
            writes(g_terminal, "")
            writes(g_terminal, "Don't forget to add any required IMPORT statements")
exitProgram,
            writes(g_terminal, "")
            display(g_terminal, "Press any key to continue ")
            onerror done
            accept(g_terminal, ctr, done, WAIT:5)
done,
            offerror
            end

        xcall u_finish()
        freturn stopStatus
endfunction

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

subroutine dtk_start
opt in  a_winlib        ,a              ;window library name
endparams
.include 'WND:tkctl.def'
proc
        xcall u_start(a_winlib,,,,,,, D_DTK_FIRST_CHANNEL)
        xcall e_sect("Toolkit Method Check Utility "+DTKPROTO_VERSION, D_CAPTION)

        ;if the UI Toolkit throws an error, it also shuts down (i.e. closes all channels),
        ; so when we catch an error, we have to restart UI Toolkit.
        ; In order to avoid issues with UI Toolkit closing channels, the main channels
        ; are opened outside UI Toolkit.
        g_throwabort = 1
        xreturn
endsubroutine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; 0=ok, else error opening/creating files

function process_window_library ,i
req in  a_winlib        ,a              ;window library name
req in  a_logging       ,boolean        ;logging in use
endparams

.include 'WND:tools.def'
.include 'WND:system.def'
.include 'WND:setinf.def'
.include 'WND:fldinf.def'
.include 'DBLDIR:windows.def'

structure wnd
        name            ,a15
endstructure

record lcl_vars
        fstatus         ,i4                 ;function return status
        wndid           ,i4                 ;window id
        src_ch          ,i4                 ;source file channel
        inc_ch          ,i4                 ;include file channel
        log_ch          ,i4                 ;log file channel
        set_num         ,i4                 ;set number in input window
        fld_num         ,i4                 ;field number in set
        search          ,i4                 ;search flag
        errnum          ,i4                 ;error flag
        routine_count   ,i4                 ;routine count
        subroutine_num  ,i4                 ;subroutine count
        sts             ,i4                 ;status
        wnd_cnt         ,i4                 ;window count
        num_wnds        ,i4                 ;number of windows
        hdl             ,D_HANDLE           ;array of window names
        logging         ,boolean            ;logging in use

        wnd_name        ,a15                ;window name
        set_name        ,a30                ;set name in input window
        fld_name        ,a30                ;field name in set
        winlib_name     ,a256               ;window library name
        file_name       ,a256               ;filename (parsed from window name)
        src_name        ,a256               ;source filename
        inc_name        ,a256               ;include filename
        log_name        ,a256               ;log filename

        lst_method      ,a DS_METHODNAMSIZ
        lst_arrive      ,a DS_METHODNAMSIZ
        lst_leave       ,a DS_METHODNAMSIZ
        lst_dblclk      ,a DS_METHODNAMSIZ

        werr_txt        ,a80                ;window error text
endrecord

proc

        init lcl_vars

        winlib_name = a_winlib
        logging = a_logging

        ;;g_utlib is used to load windows for UI Toolkit processing
        xcall u_open(g_utlib, 'I:I', winlib_name,,, errnum)
        if(errnum)
            begin
            if(g_terminal > 0)
                writes(g_terminal, "Error "+%string(errnum)+" opening window library "+winlib_name(1:%trim(winlib_name)))
            freturn 1
            end

        ;;get a count of the windows in the window library
        wnd_cnt = %u_enumwnds(g_utlib)
        if(wnd_cnt > 0) then
            call process_window_library
        else
            begin
            if(g_terminal > 0)
                writes(g_terminal, "No windows in window library "+winlib_name(1:%trim(winlib_name)))
            end

        xcall u_close(g_utlib)

        freturn fstatus

;----------------------------------------------------------------------------

process_window_library,

        xcall parse(winlib_name,,,,, file_name)
        src_name = file_name(1:%trim(file_name)) + '_src.dbl'
        inc_name = file_name(1:%trim(file_name)) + '_inc.dbl'
        log_name = file_name(1:%trim(file_name)) + '_log.log'

        ;;create source code file
        src_ch = %syn_freechn(, D_DTK_FIRST_CHANNEL-1)
        open(src_ch, 'O', src_name, TEMPFILE) [ERR=src_open_error]
        if(FALSE)
            begin
src_open_error,
            errnum = %error
            if(g_terminal > 0)
                writes(g_terminal, "Error "+%string(errnum)+" creating "+src_name(1:%trim(src_name)))
            fstatus = 2
            return
            end

        ;;create include file (for external functions)
        inc_ch = %syn_freechn(, D_DTK_FIRST_CHANNEL-1)
        open(inc_ch, 'O', inc_name, TEMPFILE) [ERR=inc_open_error]
        if(FALSE)
            begin
inc_open_error,
            errnum = %error
            purge src_ch
            if(g_terminal > 0)
                writes(g_terminal, "Error "+%string(errnum)+" creating "+inc_name(1:%trim(inc_name)))
            fstatus = 3
            return
            end

        ;;create log file
        if(logging == TRUE) then
            begin
            log_ch = %syn_freechn(, D_DTK_FIRST_CHANNEL-1)
            open(log_ch, 'O', log_name, TEMPFILE) [ERR=log_open_error]
            if(FALSE)
                begin
log_open_error,
                errnum = %error
                if(g_terminal > 0)
                    writes(g_terminal, "Error "+%string(errnum)+" creating "+log_name(1:%trim(log_name)))
                log_ch = g_terminal
                end
            end
        else
            log_ch = g_terminal

        ;;get list of windows in window library
        hdl = %mem_proc(DM_ALLOC.bor.DM_BLANK, ^size(wnd)*wnd_cnt)
        num_wnds = %u_enumwnds(g_utlib, wnd_cnt, ^m(wnd[1],hdl))

        xcall toolkit_inc_start(inc_ch)

        clear subroutine_num
        xcall toolkit_src_start(src_ch, file_name, subroutine_num, inc_name)

        clear wnd_cnt
        while(wnd_cnt < num_wnds)
            begin
            wnd_cnt += 1
            wnd_name = ^m(wnd[wnd_cnt], hdl)
            if(log_ch > 0)
                writes(log_ch, file_name(1:%trim(file_name))+"  "+wnd_name)

            clear errnum, werr_txt
            try
                begin
                xcall u_ldwnd(wndid,, wnd_name, D_NOPLC, search, errnum)
                end
            catch (e, @exception)
                begin
                errnum = 53
                werr_txt = e.ToString()
                xcall dtk_start(winlib_name)
                end
            endtry
            if(errnum)
                begin
                ;;get last UI Toolkit system error
                if(errnum < 0)
                    xcall u_getwnderr(werr_txt)
                if(werr_txt) then
                    begin
                    ;;write comment line with window name and last window error
                    writes(src_ch, ';skipped: '+wnd_name(1:%trim(wnd_name))+"  ["+werr_txt(1:%trim(werr_txt))+"]")
                    if(log_ch > 0)
                        writes(log_ch, 'skipped: '+wnd_name(1:%trim(wnd_name))+"  ["+werr_txt(1:%trim(werr_txt))+"]")
                    end
                else
                    begin
                    ;;write comment line with window name
                    writes(src_ch, ';skipped: '+wnd_name(1:%trim(wnd_name)))
                    if(log_ch > 0)
                        writes(log_ch, 'skipped: '+wnd_name(1:%trim(wnd_name)))
                    end
                nextloop
                end

            using %u_wndtype(wndid) select
            (D_WTYPE_LISTCLASS),
                begin
                data opt ,i4
                sts = %l_classinfo(wndid, D_LMETHOD, opt=D_LLOAD, lst_method)
                sts = %l_classinfo(wndid, D_LMETHOD, opt=D_LARRIVE, lst_arrive)
                sts = %l_classinfo(wndid, D_LMETHOD, opt=D_LLEAVE, lst_leave)
                sts = %l_classinfo(wndid, D_LMETHOD, opt=D_LDBLCLK, lst_dblclk)
                call process_listclass
                end
            (D_WTYPE_INPUT),
                begin
                ;;delete the window (loaded with U_LDWND) & reload with I_LDINP
                xcall u_window(D_DELETE, wndid)
                clear errnum, werr_txt
                try
                    begin
                    xcall i_ldinp(wndid,, wnd_name, D_NOPLC,, errnum)
                    end
                catch (e, @exception)
                    begin
                    errnum = 53
                    werr_txt = e.ToString()
                    xcall dtk_start(winlib_name)
                    end
                endtry
                if(errnum)
                    begin
                    ;;get last UI Toolkit system error
                    if(errnum < 0)
                        xcall u_getwnderr(werr_txt)
                    if(werr_txt) then
                        begin
                        ;;write comment line with window name and last window error
                        writes(src_ch, ';skipped input window: '+wnd_name(1:%trim(wnd_name))+"  ["+werr_txt(1:%trim(werr_txt))+"]")
                        if(log_ch > 0)
                            writes(log_ch, 'skipped input window: '+wnd_name(1:%trim(wnd_name))+"  ["+werr_txt(1:%trim(werr_txt))+"]")
                        end
                    else
                        begin
                        ;;write comment line with window name
                        writes(src_ch, ';skipped input window: '+wnd_name(1:%trim(wnd_name)))
                        if(log_ch > 0)
                            writes(log_ch, 'skipped input window: '+wnd_name(1:%trim(wnd_name)))
                        end
                    nextloop
                    end
                call process_input_window
                end
            endusing
            xcall u_window(D_DELETE, wndid)
            end
eof,
        xcall toolkit_src_end(src_ch)
        xcall toolkit_inc_end(inc_ch)

        close src_ch
        close inc_ch

        if(log_ch > 0 && log_ch != g_terminal)
            begin
            writes(log_ch, file_name(1:%trim(file_name)) + " PROCESSED")
            close log_ch
            end

        hdl = %mem_proc(DM_FREE, hdl)

        return

;----------------------------------------------------------------------------

process_input_window,

        call check_routine_count

        ;;write comment line with window name
        writes(src_ch, ';input window: '+wnd_name(1:%trim(wnd_name)))

        for fld_num from 1 thru %i_info(wndid, D_NMFLDS)
            begin
            clear fld_name
            xcall i_fldinf(wndid, fld_name, fld_num,, gs_inpfld)
            if(!fld_name)
                nextloop

            call write_input_methods
            end

        return

;----------------------------------------------------------------------------

write_input_methods,

        if(gs_arrive || gs_leave || gs_change || gs_drill || gs_hyperlink || gs_display || gs_editfmt)
            begin
            writes(src_ch, ';field: '+fld_name(1:%trim(fld_name)))

            ;;not trimming routine name, for readability
            if(gs_arrive)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_arrive+'(inputinfo, inprec) ;arrive opt=3')
                end
            if(gs_leave)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_leave+'(inputinfo, inprec) ;leave opt=3')
                end
            if(gs_change)
                begin
                routine_count += 1
                writes(inc_ch, gs_change+' ,^VAL')
                writes(src_ch, 'sts= %'+gs_change+'(data_entered, data_stored, pending_status, inputinfo, inprec) ;change opt=6')
                end
            if(gs_drill)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_drill+'(inputinfo, inprec) ;drill opt=3')
                end
            if(gs_hyperlink)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_hyperlink+'(inputinfo, inprec) ;hyperlink opt=3')
                end
            if(gs_display)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_display+'(data_stored, data_displayed, inputinfo, inprec, attributes, color) ;display opt=7')
                end
            if(gs_editfmt)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+gs_editfmt+'(data_stored, data_edit, inputinfo, inprec, attributes, color) ;editfmt opt=7')
                end
            end

        return

;----------------------------------------------------------------------------

process_listclass,

        call check_routine_count

        ;;write comment line with window name
        writes(src_ch, ';listclass: '+wnd_name(1:%trim(wnd_name)))

        if(lst_method || lst_arrive || lst_leave || lst_dblclk)
            begin
            ;;not trimming routine name, for readability
            if(lst_method)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+lst_method+'(listid, req, inprec, inpid, disabled, index) ;load opt=7')
                end
            if(lst_arrive)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+lst_arrive+'(sts, listid, winEvent, inprec, disabled, index, row) ;arrive opt=8')
                end
            if(lst_leave)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+lst_leave+'(sts, listid, winEvent, inprec, disabled, index, row) ;leave opt=8')
                end
            if(lst_dblclk)
                begin
                routine_count += 1
                writes(src_ch, 'xcall '+lst_dblclk+'(sts, listid, inprec, inpid, disabled, index, row) ;dblclk opt=8')
                end
            end

        return

;----------------------------------------------------------------------------

check_routine_count,

        if(routine_count > 2000)
            begin
            ;;break code into subroutines, to avoid a SEGBIG error
            xcall toolkit_src_end(src_ch)

            subroutine_num += 1
            xcall toolkit_src_start(src_ch, file_name, subroutine_num, inc_name)
            clear routine_count
            end

        return

;----------------------------------------------------------------------------

endfunction


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

subroutine toolkit_src_start
req in  a_src_ch    ,n                  ;channel
req in  a_sub_name  ,a                  ;subroutine name
req in  a_sub_count ,n                  ;count
req in  a_inc_name  ,a                  ;include file name
endparams
proc
        if(a_sub_count > 0) then
            writes(a_src_ch, 'subroutine '+a_sub_name(1:%trim(a_sub_name))+%string(a_sub_count))
        else
            begin
            writes(a_src_ch, ';add IMPORT statements here')
            writes(a_src_ch, 'subroutine '+a_sub_name(1:%trim(a_sub_name)))
            end
        writes(a_src_ch, '.include "'+a_inc_name(1:%trim(a_inc_name))+'" ;external functions')
        writes(a_src_ch, 'record')
        writes(a_src_ch, '.include "WND:inpinf.def"')
        writes(a_src_ch, 'record')
        writes(a_src_ch, 'inprec         ,a1')
        writes(a_src_ch, 'data_entered   ,a1')
        writes(a_src_ch, 'data_stored    ,a1')
        writes(a_src_ch, 'data_displayed ,a1')
        writes(a_src_ch, 'data_edit      ,a1')
        writes(a_src_ch, 'pending_status ,i4')
        writes(a_src_ch, 'attributes     ,i4')
        writes(a_src_ch, 'color          ,i4')
        writes(a_src_ch, 'sts            ,i4')
        writes(a_src_ch, 'listid         ,i4')
        writes(a_src_ch, 'inpid          ,i4')
        writes(a_src_ch, 'req            ,i4')
        writes(a_src_ch, 'disabled       ,i4')
        writes(a_src_ch, 'index          ,i4')
        writes(a_src_ch, 'row            ,i4')
        writes(a_src_ch, 'winEvent       ,i4')
        writes(a_src_ch, 'proc')
        xreturn
endsubroutine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

subroutine toolkit_src_end
req in  a_src_ch    ,n                  ;channel
endparams
proc
        writes(a_src_ch, 'xreturn')
        writes(a_src_ch, 'endsubroutine')
        xreturn
endsubroutine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

subroutine toolkit_inc_start
req in  a_inc_ch    ,n                  ;channel
endparams
proc
        writes(a_inc_ch, 'external function')
        xreturn
endsubroutine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

subroutine toolkit_inc_end
req in  a_inc_ch    ,n                  ;channel
endparams
proc
        writes(a_inc_ch, 'endexternal')
        xreturn
endsubroutine

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

